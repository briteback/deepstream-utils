<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"record.js.html":{"id":"record.js.html","title":"Source: record.js","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Source: record.js /** * Callback handler for promiseSet. Rejects if there was an error, else resolves. * @param {Function} resolve * @param {Function} reject */ function finishWriteAck(resolve, reject) { return error =&gt; { if (error) reject(error); else resolve(); }; } /** * A Promise-wrapped record.set() which resolves after write acknowledgement. * @param {String} [path] A path for the value to be set on the record. * @param {*} value The value to be set at the path, or an object containing the entire record data to set. * @param {Boolean} [discard] Whether or not to discard the record. * @returns {Promise} */ function promiseSet(path, value, discard) { return new Promise((resolve, reject) =&gt; { if (typeof path === 'object') { discard = value; this.set(path, finishWriteAck(resolve, reject)); } else { this.set(path, value, finishWriteAck(resolve, reject)); } }).then(() =&gt; { if (discard) { this.discard(); } return this; }); } /** * Adds a Promise-wrapped record.set() to a Deepstream record, for easy write acknowledgement. * @param {Record} record A Deepstream record to add pSet to (modifies record) * @returns {Record} */ function addPromiseSet(record) { record.pSet = promiseSet.bind(record); return record; } class RecordUtils { /** * Constructor for the record utils * @param {Object} client A deepstream client to be used for the requests */ constructor(client, options) { this.options = options; this.client = client; this.setDataCallbacks = new Map(); /** * Get the entries of a list. * @param {String} listName * @returns {Promise.&lt;Array&gt;} */ this.getEntries = this.snapshot; } /** * Set data on a existing or new record without subscribing. * @param {Array} args - First element will contain the record name, * second element is a key or object, and if the second element is a * key the third element must be the value. * @param {Boolean} create - If the given recor name should be created * @returns {Promise} */ _setData(args, create) { const [recordName] = args; return new Promise((resolve, reject) =&gt; { if (!this.setDataCallbacks.has(recordName)) { this.setDataCallbacks.set(recordName, new Set([{ resolve, reject }])); } else { this.setDataCallbacks.get(recordName).add({ resolve, reject }); } this.client.record.has(recordName, (error, hasRecord) =&gt; { if (error) { return reject(error); } else if (!create &amp;&amp; !hasRecord) { return reject(`Trying to setData on nonexistent record: ${recordName}`); } else if (create &amp;&amp; hasRecord) { return reject(`Trying to create and setData on existing record: ${recordName}`); } if (args.length === 2) { return this.client.record.setData(recordName, args[1], setError =&gt; { if (error) reject(setError); else resolve(); }); } else if (args.length === 3) { return this.client.record.setData(recordName, args[1], args[2], setError =&gt; { if (error) reject(setError); else resolve(); }); } return reject(`Incorrect arguments given to setData: ${args}`); }); }).then(res =&gt; { if (this.setDataCallbacks.has(recordName)) { this.setDataCallbacks.get(recordName).forEach(({ resolve }) =&gt; resolve(res)); this.setDataCallbacks.delete(recordName); } return res; }).catch(error =&gt; { if (this.setDataCallbacks.has(recordName)) { this.setDataCallbacks.get(recordName).forEach(({ reject }) =&gt; reject(error)); this.setDataCallbacks.delete(recordName); } throw error; }); } /** * Set data; will NOT create create record! * @param {String} recordName * @param {Object | String} data or key * @param {Object} [data] * @returns {Promise} */ setData(...args) { return this._setData(args, false); } /** * Set data; WILL create record! * @param {String} recordName * @param {Object | String} data or key * @param {Object} [data] * @returns {Promise} */ createAndSetData(...args) { return this._setData(args, true); } /** * Delete a record * @param {String} recordName * @returns {Promise} */ delete(recordName) { return this.getRecord(recordName) .then(record =&gt; record.delete()); } /** * Checks if a record exists * @param {String} recordName * @returns {Promise} Resolves a boolean or rejects a error */ has(recordName) { return new Promise((resolve, reject) =&gt; { this.client.record.has(recordName, (error, hasRecord) =&gt; { if (error) reject(error); else resolve(hasRecord); }); }); } /** * Get a record, if the record didn't exist it will NOT * be created and the promise will be rejected. * Option disableHasCheck will disable this behavior and omit the check. * @param {String} recordName * @returns {Promise} Resolves the record * @throws {exception} Throws if record doesn't exist */ getRecord(recordName) { if (this.options.disableHasCheck) { return this.dsGetRecord(recordName); } return this.has(recordName) .then(hasRecord =&gt; { if (!hasRecord) { throw `No record by that name ${recordName}`; } return this.dsGetRecord(recordName); }); } /** * Create a record. Will throw if a record with that name already exists. * @param {String} recordName name of the record to be created * @returns {Promise} Resolves the created record * @throws {exception} Throws if a record with that name already exists */ createRecord(recordName) { return this.has(recordName) .then(hasRecord =&gt; { if (hasRecord) { throw `Record already exists ${recordName}`; } return this.dsGetRecord(recordName); }); } /** * Get the data from a record. * @param {String} recordName Name of the record to get a snapshot of * @returns {Promise} Resolves the record data or rejects with an error */ snapshot(recordName) { return new Promise((resolve, reject) =&gt; { this.client.record.snapshot(recordName, (error, snapshot) =&gt; { if (error) reject({ error, recordName }); else resolve(snapshot); }); }); } /** * Create or get a record. * @param {String} recordName Name of the record to get or create * @returns {Promise} Resolves an object with a created boolean and the record */ getOrCreate(recordName) { return this.has(recordName) .then(hasRecord =&gt; this.dsGetRecord(recordName) .then(record =&gt; ({ created: !hasRecord, record }))); } /** * Wraps deepstream getRecord in a promise. * @param {Object} client Deepstream client * @param {String} recordName Name of the record to get * @returns {Promise} */ dsGetRecord(recordName) { return new Promise((resolve, reject) =&gt; { const record = this.client.record.getRecord(recordName); record.whenReady(() =&gt; resolve(addPromiseSet(record))); record.on('error', err =&gt; reject(err)); }); } /** * * @param {String} recordName * @param {Boolean} ignoreWhenReady - If true; will return the list without waiting * for when ready else a promise will be returned that resolves when the whenReady * callback is called. */ getList(listName, ignoreWhenReady) { if (ignoreWhenReady) { return this.client.record.getList(listName); } return new Promise((resolve, reject) =&gt; { const list = this.client.record.getList(listName); list.whenReady(() =&gt; resolve(list)); list.once('error', err =&gt; reject(err)); }); } /** * Add the entry to the list and discard. * @param {String} listName * @param {String} entry * @returns {Promise} */ addEntry(listName, entry, index) { return this.getList(listName) .then(list =&gt; { list.addEntry(entry, index); setTimeout(() =&gt; list.discard(), 10000); }); } /** * Remove the entry from the list and discard. * @param {String} listName * @param {String} entry * @returns {Promise} */ removeEntry(listName, entry, index) { return this.getList(listName) .then(list =&gt; { list.removeEntry(entry, index); setTimeout(() =&gt; list.discard(), 10000); }); } /** * Delete the list * @param {String} listName * @returns {Promise} */ deleteList(listName) { return this.getList(listName) .then(list =&gt; list.delete()); } /** * Check if the list includes the given entry. * @param {String} listName * @param {String} entry * @returns {Promise.&lt;Boolean&gt;} */ listIncludes(listName, entry) { return this.getEntries(listName) .then(entries =&gt; entries.includes(entry)); } } module.exports = RecordUtils; Ã— Search results Close "},"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Source: client.js const deepstreamClient = require('deepstream.io-client-js'); const RecordUtils = require('./record'); const RpcUtils = require('./rpc'); class DeepstreamUtils { /** * Constructor for the deepstream utilsb * @param {Object} options * @param {String} options.host Url for the client * @param {Object} options.clientOptions Options for the client * @param {Object} options.authParams Authentication parameters for the client on login * @param {Object} options.disableHasCheck Dont check if record exists in getRecord */ constructor(options) { this.options = options; this.client = null; this.hasInitialized = false; this.record = new RecordUtils(this.client, options); this.rpc = new RpcUtils(this.client, options); } /** * Initiate the client and login * @returns {Promise} Resolves when the client has logged in */ initClient() { this.client = deepstreamClient(this.options.host, this.options.clientOptions); // TODO: this should be done better... this.record.client = this.client; this.rpc.client = this.client; this.client.on('error', (error, event, topic) =&gt; { console.error('Deepstream client error:', { error, event, topic }); }); return this.client; } /** * The first time this function is called it runs login on * the client and after that it returns the same Promise. * @returns {Promise} */ login() { if (!this.loginPromise) { this.loginPromise = this.baseLogin(this.options.authParams) .then(loginData =&gt; { this.hasInitialized = true; return loginData; }) .catch(error =&gt; { this.loginPromise = null; throw error; }); } return this.loginPromise; } /** * Close (logout) the client * @returns {Promise} */ close() { if (this.loginPromise) { return this.loginPromise .catch(error =&gt; { console.error('Error with loginPromise on close', error); }) .then(() =&gt; { this.client.close(); this.loginPromise = null; }); } return Promise.resolve(); } /** * Wraps the deepstream client login function in a promise * @param {Object} authParams * @returns {Promise} Resolves when the client has logged in */ baseLogin(authParams) { return new Promise((resolve, reject) =&gt; { this.client.login(authParams, (success, data) =&gt; { if (!success) { return reject({ code: 0, message: data }); } return resolve(data); }); }); } } DeepstreamUtils.MERGE_STRATEGIES = deepstreamClient.MERGE_STRATEGIES; module.exports = DeepstreamUtils; Ã— Search results Close "},"rpc.js.html":{"id":"rpc.js.html","title":"Source: rpc.js","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Source: rpc.js const RETRYINTERVAL = 500; const RETRYTIMEOUT = 60000; class RpcUtils { /** * Constructor for the rpc utils * @param {Object} client A deepstream client to be used for the requests * @param {Object} [options] Additional options * @param {Function} [options.audit] * @param {Number} [options.retryRPCTimeout] * @param {Number} [options.retryRPCInterval] */ constructor(client, options = {}) { this.options = options; this.audit = options.audit; this.client = client; this.retryRPCTimeout = options.retryRPCTimeout === undefined ? RETRYTIMEOUT : options.retryRPCTimeout; this.retryRPCInterval = options.retryRPCInterval || RETRYINTERVAL; } /** * Will retry to call the RPC until retryRPCTimeout is reached or the RPC returns * something different than NO_RPC_PROVIDER * @param {Function} resolve * @param {Function} reject * @param {String} rpc * @param {Object} data * @param {Number} start */ retryRPCMake(resolve, reject, rpc, data, start) { setTimeout(() =&gt; { this.client.rpc.make(rpc, data, (error, result) =&gt; { if (!error) { resolve(result); } else if (error === 'NO_RPC_PROVIDER' &amp;&amp; Date.now() - start &lt; this.retryRPCTimeout) { this.retryRPCMake(resolve, reject, rpc, data, start); } else { reject(error); } }); }, this.retryRPCInterval); } /** * Makes a rpc call * @param {String} rpc * @param {*} data * @returns {Promise} Resolves with rpc data */ make(rpc, data) { return new Promise((resolve, reject) =&gt; { this.client.rpc.make(rpc, data, (error, result) =&gt; { if (error === null) { resolve(result); } else if (error === 'NO_RPC_PROVIDER' &amp;&amp; this.retryRPCTimeout !== 0) { this.retryRPCMake(resolve, reject, rpc, data, Date.now()); } else { reject(error); } }); }); } /** * Provide a rpc * @param {String} rpc RPC name * @param {function} cb * @param {Object} [options] If options and an audit function are specified, * the audit function will be called with options and rpc data. */ provide(rpc, cb, options) { if (options &amp;&amp; this.audit) { this.client.rpc.provide(rpc, async (data, response) =&gt; { const send = response.send.bind(response); const error = response.error.bind(response); response.send = async result =&gt; { send(result); await this.audit({ rpc, data, result, error: false, options }); console.log('DONE!!'); }; response.error = result =&gt; { error(result); this.audit({ rpc, data, result, error: true, options }); }; cb(data, response); }); } else { this.client.rpc.provide(rpc, cb); } } } module.exports = RpcUtils; Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Global Methods addPromiseSet(record) Adds a Promise-wrapped record.set() to a Deepstream record, for easy write acknowledgement. Parameters: Name Type Description record Record A Deepstream record to add pSet to (modifies record) Source: record.js, line 42 Returns: Type Record finishWriteAck(resolve, reject) Callback handler for promiseSet. Rejects if there was an error, else resolves. Parameters: Name Type Description resolve function reject function Source: record.js, line 7 promiseSet( [path], value [, discard]) A Promise-wrapped record.set() which resolves after write acknowledgement. Parameters: Name Type Argument Description path String &lt;optional&gt; A path for the value to be set on the record. value * The value to be set at the path, or an object containing the entire record data to set. discard Boolean &lt;optional&gt; Whether or not to discard the record. Source: record.js, line 21 Returns: Type Promise Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Classes Classes DeepstreamUtils RecordUtils RpcUtils Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet deepstream-utils Ã— Search results Close "},"DeepstreamUtils.html":{"id":"DeepstreamUtils.html","title":"Class: DeepstreamUtils","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Class: DeepstreamUtils DeepstreamUtils new DeepstreamUtils(options) Constructor for the deepstream utilsb Parameters: Name Type Description options Object Properties Name Type Description host String Url for the client clientOptions Object Options for the client authParams Object Authentication parameters for the client on login disableHasCheck Object Dont check if record exists in getRecord Source: client.js, line 15 Methods baseLogin(authParams) Wraps the deepstream client login function in a promise Parameters: Name Type Description authParams Object Source: client.js, line 84 Returns: Resolves when the client has logged in Type Promise close() Close (logout) the client Source: client.js, line 64 Returns: Type Promise initClient() Initiate the client and login Source: client.js, line 28 Returns: Resolves when the client has logged in Type Promise login() The first time this function is called it runs login onthe client and after that it returns the same Promise. Source: client.js, line 45 Returns: Type Promise Ã— Search results Close "},"RecordUtils.html":{"id":"RecordUtils.html","title":"Class: RecordUtils","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Class: RecordUtils RecordUtils new RecordUtils(client) Constructor for the record utils Parameters: Name Type Description client Object A deepstream client to be used for the requests Source: record.js, line 53 Members getEntries Get the entries of a list. Source: record.js, line 63 Methods _setData(args, create) Set data on a existing or new record without subscribing. Parameters: Name Type Description args Array First element will contain the record name,second element is a key or object, and if the second element is akey the third element must be the value. create Boolean If the given recor name should be created Source: record.js, line 74 Returns: Type Promise addEntry(listName, entry) Add the entry to the list and discard. Parameters: Name Type Description listName String entry String Source: record.js, line 275 Returns: Type Promise createAndSetData(recordName, data [, data]) Set data; WILL create record! Parameters: Name Type Argument Description recordName String data Object | String or key data Object &lt;optional&gt; Source: record.js, line 139 Returns: Type Promise createRecord(recordName) Create a record. Will throw if a record with that name already exists. Parameters: Name Type Description recordName String name of the record to be created Source: record.js, line 195 Throws: Throws if a record with that name already exists Type exception Returns: Resolves the created record Type Promise delete(recordName) Delete a record Parameters: Name Type Description recordName String Source: record.js, line 148 Returns: Type Promise deleteList(listName) Delete the list Parameters: Name Type Description listName String Source: record.js, line 302 Returns: Type Promise dsGetRecord(client, recordName) Wraps deepstream getRecord in a promise. Parameters: Name Type Description client Object Deepstream client recordName String Name of the record to get Source: record.js, line 242 Returns: Type Promise getList(recordName, ignoreWhenReady) Parameters: Name Type Description recordName String ignoreWhenReady Boolean If true; will return the list without waitingfor when ready else a promise will be returned that resolves when the whenReadycallback is called. Source: record.js, line 258 getOrCreate(recordName) Create or get a record. Parameters: Name Type Description recordName String Name of the record to get or create Source: record.js, line 226 Returns: Resolves an object with a created boolean and the record Type Promise getRecord(recordName) Get a record, if the record didn't exist it will NOTbe created and the promise will be rejected.Option disableHasCheck will disable this behavior and omit the check. Parameters: Name Type Description recordName String Source: record.js, line 175 Throws: Throws if record doesn't exist Type exception Returns: Resolves the record Type Promise has(recordName) Checks if a record exists Parameters: Name Type Description recordName String Source: record.js, line 158 Returns: Resolves a boolean or rejects a error Type Promise listIncludes(listName, entry) Check if the list includes the given entry. Parameters: Name Type Description listName String entry String Source: record.js, line 313 Returns: Type Promise.&lt;Boolean&gt; removeEntry(listName, entry) Remove the entry from the list and discard. Parameters: Name Type Description listName String entry String Source: record.js, line 289 Returns: Type Promise setData(recordName, data [, data]) Set data; will NOT create create record! Parameters: Name Type Argument Description recordName String data Object | String or key data Object &lt;optional&gt; Source: record.js, line 128 Returns: Type Promise snapshot(recordName) Get the data from a record. Parameters: Name Type Description recordName String Name of the record to get a snapshot of Source: record.js, line 211 Returns: Resolves the record data or rejects with an error Type Promise Ã— Search results Close "},"RpcUtils.html":{"id":"RpcUtils.html","title":"Class: RpcUtils","body":" DocStrap Classes DeepstreamUtilsRecordUtilsRpcUtils Global addPromiseSetfinishWriteAckpromiseSet Class: RpcUtils RpcUtils new RpcUtils(client [, options]) Constructor for the rpc utils Parameters: Name Type Argument Description client Object A deepstream client to be used for the requests options Object &lt;optional&gt; Additional options Properties Name Type Argument Description audit function &lt;optional&gt; retryRPCTimeout Number &lt;optional&gt; retryRPCInterval Number &lt;optional&gt; Source: rpc.js, line 13 Methods make(rpc, data) Makes a rpc call Parameters: Name Type Description rpc String data * Source: rpc.js, line 53 Returns: Resolves with rpc data Type Promise provide(rpc, cb [, options]) Provide a rpc Parameters: Name Type Argument Description rpc String RPC name cb function options Object &lt;optional&gt; If options and an audit function are specified, the audit function will be called with options and rpc data. Source: rpc.js, line 74 retryRPCMake(resolve, reject, rpc, data, start) Will retry to call the RPC until retryRPCTimeout is reached or the RPC returnssomething different than NO_RPC_PROVIDER Parameters: Name Type Description resolve function reject function rpc String data Object start Number Source: rpc.js, line 33 Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
